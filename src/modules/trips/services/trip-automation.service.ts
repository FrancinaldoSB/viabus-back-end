import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { RouteSchedule } from '../../routes/entities/route-schedule.entity';
import { RouteStop } from '../../routes/entities/route-stop.entity';
import { Route } from '../../routes/entities/route.entity';
import { Trip, TripStatus } from '../entities/trip.entity';

@Injectable()
export class TripAutomationService {
  constructor(
    @InjectRepository(Trip)
    private tripRepository: Repository<Trip>,
    @InjectRepository(RouteSchedule)
    private routeScheduleRepository: Repository<RouteSchedule>,
    @InjectRepository(Route)
    private routeRepository: Repository<Route>,
    @InjectRepository(RouteStop)
    private routeStopRepository: Repository<RouteStop>,
  ) {}

  /**
   * Encontra ou cria uma viagem para a rota e data especificadas
   */
  async findOrCreateTrip(
    routeId: string,
    travelDate: string,
    departureTime?: string,
    companyId?: string,
  ): Promise<Trip> {
    // Se departureTime não foi fornecido, busca automaticamente da primeira parada
    let actualDepartureTime = departureTime;
    if (!actualDepartureTime) {
      const firstStop = await this.routeStopRepository.findOne({
        where: { routeId, order: 1 },
      });

      // Se não encontrou parada ou o horário está null, usa horário padrão
      actualDepartureTime = firstStop?.departureTime || '08:00';
    }

    // Primeiro, verifica se já existe uma viagem para esta rota, data e horário
    const existingTrip = await this.findExistingTrip(
      routeId,
      travelDate,
      actualDepartureTime,
    );

    if (existingTrip) {
      return existingTrip;
    }

    // Se não existe, cria uma nova baseada no schedule e paradas
    return this.createTripFromRouteStops(
      routeId,
      travelDate,
      actualDepartureTime,
      companyId || '',
    );
  }

  /**
   * Busca uma viagem existente para rota, data e horário
   */
  private async findExistingTrip(
    routeId: string,
    travelDate: string,
    departureTime: string,
  ): Promise<Trip | null> {
    const departureDateTime = new Date(`${travelDate}T${departureTime}:00`);

    return this.tripRepository.findOne({
      where: {
        routeId,
        departureTime: departureDateTime,
      },
      relations: ['route', 'tripVehicles'],
    });
  }

  /**
   * Cria uma nova viagem baseada nas paradas da rota
   */
  private async createTripFromRouteStops(
    routeId: string,
    travelDate: string,
    departureTime: string,
    companyId: string,
  ): Promise<Trip> {
    // Verifica se a rota está ativa no dia da semana
    const travelDateObj = new Date(travelDate);
    const dayOfWeek = travelDateObj.getDay();

    const schedule = await this.routeScheduleRepository.findOne({
      where: {
        routeId,
        dayOfWeek,
        isActive: true,
      },
      relations: ['route'],
    });

    if (!schedule) {
      throw new Error(
        `Rota ${routeId} não está ativa no dia da semana ${dayOfWeek}`,
      );
    }

    // Busca a primeira parada (parada de origem) para validar o horário
    const firstStop = await this.routeStopRepository.findOne({
      where: { routeId, order: 1 },
      relations: ['stop'],
    });

    // Se não tem primeira parada, não pode criar a viagem
    if (!firstStop) {
      throw new Error(`Nenhuma parada encontrada para a rota ${routeId}`);
    }

    // Validar horário: usa o horário da parada ou permite o horário solicitado se a parada não tem horário definido
    const stopDepartureTime = firstStop.departureTime;
    const finalDepartureTime = stopDepartureTime || departureTime;
    
    // Se a parada tem horário definido, deve corresponder ao solicitado
    if (stopDepartureTime && stopDepartureTime !== departureTime) {
      throw new Error(
        `Horário ${departureTime} não corresponde ao horário da primeira parada (${stopDepartureTime}) da rota ${routeId}`,
      );
    }

    // Busca a última parada para calcular o tempo estimado de chegada
    const lastStop = await this.routeStopRepository.findOne({
      where: { routeId },
      order: { order: 'DESC' },
    });

    // Calcula horários de partida e chegada
    const departureDateTime = new Date(`${travelDate}T${finalDepartureTime}:00`);
    const estimatedArrivalDateTime = lastStop?.departureTime
      ? new Date(`${travelDate}T${lastStop.departureTime}:00`)
      : new Date(departureDateTime.getTime() + 2 * 60 * 60 * 1000); // Default: +2 horas

    // Cria a viagem
    const trip = this.tripRepository.create({
      routeId,
      departureTime: departureDateTime,
      estimatedArrivalTime: estimatedArrivalDateTime,
      status: TripStatus.SCHEDULED,
      basePrice: 0, // Preço será definido posteriormente pelo módulo de precificação
      totalSeats: 0, // Será calculado quando veículos forem adicionados
      availableSeats: 0,
      isAutoGenerated: true,
      companyId,
      tripVehicles: [], // Inicialmente sem veículos
    });

    return this.tripRepository.save(trip);
  }

  /**
   * Retorna as datas e horários disponíveis para uma rota
   */
  async getAvailableDatesForRoute(
    routeId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<{ date: string; times: string[] }[]> {
    try {
      // Busca os dias ativos da rota
      const schedules = await this.routeScheduleRepository.find({
        where: {
          routeId,
          isActive: true,
        },
      });

      if (schedules.length === 0) {
        return [];
      }

      // Busca todos os horários das paradas (primeira parada = horário de saída)
      const routeStops = await this.routeStopRepository.find({
        where: { routeId },
        order: { order: 'ASC' },
      });

      // Pega o horário da primeira parada (origem)
      const firstStop = routeStops.find((stop) => stop.order === 1);

      // Se não tem paradas ou a primeira parada não tem horário definido,
      // usa um horário padrão para permitir agendamentos
      const departureTime = firstStop?.departureTime || '08:00';

      const availableDates: { date: string; times: string[] }[] = [];
      const currentDate = new Date(startDate);

      while (currentDate <= endDate) {
        const dayOfWeek = currentDate.getDay();
        const isActiveDay = schedules.some((s) => s.dayOfWeek === dayOfWeek);

        if (isActiveDay) {
          availableDates.push({
            date: currentDate.toISOString().split('T')[0],
            times: [departureTime], // Por enquanto apenas um horário por rota
          });
        }

        currentDate.setDate(currentDate.getDate() + 1);
      }

      return availableDates;
    } catch (error) {
      console.error('Erro ao buscar datas disponíveis:', error);
      return [];
    }
  }

  /**
   * Retorna todos os horários disponíveis para uma rota (das paradas)
   */
  async getRouteAvailableTimes(routeId: string): Promise<string[]> {
    const routeStops = await this.routeStopRepository.find({
      where: { routeId },
      order: { order: 'ASC' },
    });

    // Por enquanto, retorna apenas o horário da primeira parada
    // Futuramente pode ser expandido para múltiplos horários
    const firstStop = routeStops.find((stop) => stop.order === 1);
    const departureTime = firstStop?.departureTime || '08:00';
    return [departureTime];
  }

  /**
   * Calcula e atualiza o total de assentos da viagem baseado nos veículos
   */
  async updateTripSeats(tripId: string): Promise<void> {
    const trip = await this.tripRepository.findOne({
      where: { id: tripId },
      relations: ['tripVehicles', 'tripVehicles.vehicle', 'tickets'],
    });

    if (!trip) {
      throw new Error(`Viagem com ID ${tripId} não encontrada`);
    }

    // Calcula total de assentos baseado nos veículos (se houver veículos configurados)
    const totalSeats = trip.tripVehicles?.length > 0 
      ? trip.tripVehicles
          .filter((tv) => tv.isActive)
          .reduce((sum, tv) => sum + (tv.vehicle?.capacity || 0), 0)
      : 0;

    // Calcula assentos ocupados baseado nos tickets confirmados e reservados
    const occupiedSeats = trip.tickets?.filter(
      (ticket) => ticket.status === 'confirmed' || ticket.status === 'reserved',
    ).length || 0;

    // Se não há veículos configurados ainda, mantém a lógica atual
    // mas permite que tickets sejam criados mesmo sem definir capacidade
    trip.totalSeats = totalSeats;
    trip.availableSeats = totalSeats > 0 ? totalSeats - occupiedSeats : 999; // Valor alto para viagens sem veículos ainda

    await this.tripRepository.save(trip);
  }
}
